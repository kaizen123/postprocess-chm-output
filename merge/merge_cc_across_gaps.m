function cc = merge_cc_across_gaps(cc, opts)
% Merges the provided connected components based on overlap across missing
% slices in the axial dimension. The number of desired missing slices to
% look across is provided in the opts structure as opts.skip. The connected
% components structure, cc, is updated each time a merge occurs. Namely,
% the list of pixel indices is updated. Merging occurs in a bottom-to-top
% direction.
%
% Required Inputs
% ===============
%     cc       Structure of 3D connected components generated by bwconncomp 
%     opts     Structure of options provided by the calling function
%
% Output
% ======
%     cc    Updated structure of 3D connected components that reflects the
%           results of the merging operations.
%
% See also buildSliceStruct, findMerges
%

% Build the slice structure
[objects, cc] = buildSliceStruct(cc, opts);

% Loop over the objects to be checked
while objects.check
    obj = objects.check(1);
    fprintf('Object %s\n', sprintf('%06d', obj));
    fprintf('=============\n');
    fprintf('Min: %d, Max: %d\n', cc.zmin(obj), cc.zmax(obj));
    clear merge
    merge = obj;
    merge(2) = findMerges(obj, cc, objects, opts);
    
    % Continue to the next loop iteration if no merge is found
    if ~merge(2); 
        objects.check(1) = [];
        continue
    end
    
    % If a merge is found, continue looking until no merges are found
    while merge(end)
        if cc.zmax(merge(end)) ~= opts.stackdims(3)
            merge(numel(merge)+1) = findMerges(merge(end), cc, objects, ...
                opts);
        else
            break
        end
    end
    
    %%%
    % Perform the merging
    %%%
    
    % Remove the last entry of merge if it is a zero
    if merge(end) == 0; merge = merge(1:end - 1); end
    
    % Update the zmax values of the object to be merged to
    cc.zmax(obj) = cc.zmax(merge(end));
    
    objects.check = objects.check(objects.check ~= obj);
    
    for jj = 2:numel(merge)
        % Remove the object from the "objects to check" list
        objects.check = objects.check(objects.check ~= merge(jj));
        
        % Merge PixelIdxList cell entries
        cc.PixelIdxList{obj} = [cc.PixelIdxList{obj}; ...
            cc.PixelIdxList{merge(jj)}];
        cc.PixelIdxList{merge(jj)} = [];
        
        for kk = cc.zmin(merge(jj)) : cc.zmax(merge(jj))
            str = ['z' sprintf('%04d', kk)];
            objects.(str) = objects.(str)(objects.(str) ~= merge(jj));
            objects.(str) = sort([objects.(str) obj]);
        end
    end 
end

% Update the 3DCC structure after merging. First, remove all pixel index
% listings that are empty. Then, update the total number of objects and
% remove fields that are no longer necessary.
cc.PixelIdxList = cc.PixelIdxList(~cellfun('isempty', cc.PixelIdxList));
cc.NumObjects = numel(cc.PixelIdxList);
cc = rmfield(cc, 'zmin');
cc = rmfield(cc, 'zmax');

end
